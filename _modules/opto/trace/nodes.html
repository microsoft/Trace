
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>opto.trace.nodes &#8212; Trace</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css?v=384b581d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?v=efea14e4"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script data-domain="microsoft.github.io/trace" defer="defer" src="https://plausible.io/js/script.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js?v=36754332"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/opto/trace/nodes';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Trace</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../intro.html">
                    üéØ Trace
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">üí°Quick Start</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/installation.html">üåê  Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/quick_start.html">‚ö°Ô∏è First: 5-Minute Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/quick_start_2.html">üöÄ Next: Adaptive Agent</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/virtualhome.html">ü§Ø Finally: Emergent Behaviors</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">üìöTutorials</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/basic_tutorial.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/optimization_tutorial.html">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/error_handling_tutorial.html">Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/custom_optimizers.html">Building Custom Optimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/minibatch.html">Batch Optimization</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Agent Examples</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../examples/game/battleship.html">Single Agent: Battleship</a></li>


<li class="toctree-l1"><a class="reference internal" href="../../../examples/game/negotiation_arena.html">Multi-Agent: Negotiation Arena</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">NLP Examples</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../examples/nlp/bigbench_hard.html">BigBench-Hard</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Robotics Examples</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../examples/robotics/metaworld.html">Meta-World</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">FAQ</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../faq/faq.html">FAQ</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">üìñ API Reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api/opto/opto.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/opto/opto.trace.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.propagators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.propagators</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.graph_propagator.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.graph_propagator</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/opto/opto.utils.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.utils</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/opto/opto.utils.llm.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.utils.llm</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/opto/opto.optimizers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/opto/opto.version.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.version</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.optimizers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.optimizers.buffers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers.buffers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.optimizers.opro.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers.opro</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.optimizers.optimizer.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers.optimizer</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.optimizers.optoprime.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers.optoprime</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.optimizers.textgrad.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers.textgrad</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.optimizers.utils.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.optimizers.utils</span></code></a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api/opto/opto.trace.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.propagators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.propagators</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.graph_propagator.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.graph_propagator</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.broadcast.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.broadcast</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.bundle.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.bundle</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.containers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.containers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.errors.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.errors</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.iterators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.iterators</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.modules.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.modules</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.nodes.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.nodes</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.operators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.operators</span></code></a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.propagators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.propagators</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.graph_propagator.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.graph_propagator</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.graph_propagator.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.graph_propagator</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.propagators.propagators.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.propagators.propagators</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.trace.utils.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.trace.utils</span></code></a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../api/opto/opto.utils.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.utils</span></code></a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api/opto/opto.utils.llm.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.utils.llm</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.utils.llm.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.utils.llm</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/opto/opto.version.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">opto.version</span></code></a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/microsoft/Trace" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for opto.trace.nodes</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">heapq</span>


<div class="viewcode-block" id="node">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.node">[docs]</a>
<span class="k">def</span> <span class="nf">node</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Node object from data.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: The data to create the Node from.</span>
<span class="sd">        name (str, optional): The name of the Node.</span>
<span class="sd">        trainable (bool, optional): Whether the Node is trainable. Defaults to False.</span>
<span class="sd">        description (str, optional): A string describing the data.</span>
<span class="sd">        constraint (str, optional): A string describing any constraint that the data should obey.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Node: A Node object containing the data.</span>

<span class="sd">    Notes:</span>
<span class="sd">        If trainable=True:</span>
<span class="sd">            - If data is already a Node, extracts underlying data and updates name</span>
<span class="sd">            - Creates ParameterNode with extracted data, name, trainable=True and constraint</span>

<span class="sd">        If trainable=False:</span>
<span class="sd">            - If data is already a Node, returns it (with warning if name provided)</span>
<span class="sd">            - Otherwise creates new Node with data, name and constraint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">or</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">trainable</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_data</span>

        <span class="k">return</span> <span class="n">ParameterNode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is ignored because data is already a Node.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span><span class="p">)</span></div>



<span class="n">NAME_SCOPES</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># A stack of name scopes</span>


<div class="viewcode-block" id="Graph">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Graph">[docs]</a>
<span class="k">class</span> <span class="nc">Graph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Graph is a registry of all the nodes, forming a Directed Acyclic Graph (DAG).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        TRACE (bool): A class-level boolean attribute that determines whether the graph is traced when creating MessageNode. Default is True.</span>
<span class="sd">        _nodes (defaultdict): An instance-level attribute, which is a defaultdict of lists, used as a lookup table to find nodes by name.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The Graph class manages and organizes nodes in a Directed Acyclic Graph (DAG).</span>
<span class="sd">        It provides methods to register nodes, clear the graph, retrieve nodes by name, and identify root nodes.</span>
<span class="sd">        The `register` method assumes that elements in `_nodes` are never removed,</span>
<span class="sd">        which is important for maintaining the integrity of node names.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TRACE</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># When True, we trace the graph when creating MessageNode. When False, we don&#39;t trace the graph.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the Graph object.</span>

<span class="sd">        The initialization sets up the `_nodes` attribute as a defaultdict of lists to store nodes by their names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>  <span class="c1"># a lookup table to find nodes by name</span>

<div class="viewcode-block" id="Graph.clear">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Graph.clear">[docs]</a>
    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all nodes from the graph.</span>

<span class="sd">        The clear function iterates over the current nodes stored in the _nodes attribute and deletes each node.</span>
<span class="sd">        After all nodes have been deleted, it reinitializes the _nodes attribute to an empty defaultdict of lists.</span>
<span class="sd">        This ensures that the graph is completely cleared and ready to be repopulated with new nodes if necessary.</span>

<span class="sd">        Notes:</span>
<span class="sd">            After calling clear, any references to the previously stored nodes will become invalid.</span>
<span class="sd">            The function is called in unit tests to reset the state of the graph between test cases,</span>
<span class="sd">            ensuring that each test runs with a clean slate and is not affected by the state left by previous tests.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">del</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>

        <span class="c1"># self._levels = defaultdict(list)</span>

<div class="viewcode-block" id="Graph.register">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Graph.register">[docs]</a>
    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a node to the graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            node: The node object to be registered in the graph.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The register function should only be called after the node has been properly initialized and its name has been set.</span>
<span class="sd">            The function assumes that elements in the `_nodes` dictionary never get removed.</span>
<span class="sd">            After checking that the input is a `Node` and its name has the right format, the function splits the name of the node into the `name` variable and the identifier.</span>
<span class="sd">            The function then checks if there are any name scopes defined in the `NAME_SCOPES` list. If the length of the list is greater than 0, the name is prefixed with the last scope in the list followed by a &quot;/&quot;. This allows for scoping of node names.</span>
<span class="sd">            Finally, the function adds the node to the `_nodes` dictionary using the modified name as the key. The `_name` attribute of the node is set to the modified name followed by the index of the node in the list of nodes with the same name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">NAME_SCOPES</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">NAME_SCOPES</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># NOTE assume elements in self._nodes never get removed.</span></div>

        <span class="c1"># self._levels[node._level].append(node)</span>

<div class="viewcode-block" id="Graph.get">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Graph.get">[docs]</a>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve a node from the graph by its name.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): A string in the format &quot;name:id&quot;, where &quot;name&quot; is the name of the node and &quot;id&quot; is the identifier of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: The requested node from the graph.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Ensure that the &#39;name&#39; parameter is correctly formatted as &quot;name:id&quot; before calling this function.</span>
<span class="sd">            The function assumes that the &#39;_nodes&#39; attribute is a dictionary where each key is a node name and the corresponding value is a list of nodes.</span>
<span class="sd">            The &#39;id&#39; should be a valid index within the list of nodes for the given &#39;name&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span><span class="p">,</span> <span class="nb">id</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="nb">id</span><span class="p">)]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all root nodes in the graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of all root nodes in the graph. A root node is identified by its `is_root` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vv</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_root</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get string representation of the graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation of the `_nodes` attribute, useful for debugging and logging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get total number of nodes in the graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The total number of nodes in the graph by summing the lengths of all lists in the `_nodes` dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is the number of nodes in the graph</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span></div>



<span class="n">GRAPH</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span>  <span class="c1"># This is a global registry of all the nodes.</span>

<span class="n">USED_NODES</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># A stack of sets. This is a global registry to track which nodes are read.</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;Graph is a registry of all the nodes, forming a Directed Acyclic Graph (DAG).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        TRACE (bool): A class-level boolean attribute that determines whether the graph is traced when creating MessageNode. Default is True.</span>
<span class="sd">        _nodes (defaultdict): An instance-level attribute, which is a defaultdict of lists, used as a lookup table to find nodes by name.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The Graph class manages and organizes nodes in a Directed Acyclic Graph (DAG).</span>
<span class="sd">        It provides methods to register nodes, clear the graph, retrieve nodes by name, and identify root nodes.</span>
<span class="sd">        The `register` method assumes that elements in `_nodes` are never removed, </span>
<span class="sd">        which is important for maintaining the integrity of node names.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="AbstractNode">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.AbstractNode">[docs]</a>
<span class="k">class</span> <span class="nc">AbstractNode</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;AbstractNode represents an abstract data node in a directed graph.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data: The data stored in the node.</span>
<span class="sd">        parents: The list of parent nodes.</span>
<span class="sd">        children: The list of child nodes.</span>
<span class="sd">        name: The name of the node.</span>
<span class="sd">        py_name: The name of the node without the &quot;:&quot; character.</span>
<span class="sd">        id: The ID of the node.</span>
<span class="sd">        level: The level of the node in the graph.</span>
<span class="sd">        is_root: A boolean indicating whether the node is a root node.</span>
<span class="sd">        is_leaf: A boolean indicating whether the node is a leaf node.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The `AbstractNode` class is meant to be subclassed and extended to create specific types of nodes.</span>
<span class="sd">        The node can have multiple parents and children, forming a directed graph structure.</span>
<span class="sd">        The node has a name, which is used to identify it within the graph.</span>
<span class="sd">        The `py_name` attribute is the same as the name attribute, but with the &quot;:&quot; character removed.</span>

<span class="sd">        The node can be initialized with a value, an optional name, and an optional trainable flag.</span>
<span class="sd">        If the value is an instance of the `Node` class, the node will be initialized as a reference to that node, otherwise, the value will be stored directly in the node.</span>
<span class="sd">        The default name is generated based on the type of the value and a version number which serves as the identifier, separated by &quot;:&quot;.</span>

<span class="sd">        The `AbstractNode` class provides several properties to access its attributes. The `data` property allows access to the stored data.</span>
<span class="sd">        If the node is being traced within a context, the `data` property adds the node to the list of nodes used in that context.</span>
<span class="sd">        The `parents` property returns a list of parent nodes, and the `children` property returns a list of child nodes.</span>
<span class="sd">        The `name` property returns the name of the node, and the `py_name` property returns the name without the &quot;:&quot; character.</span>
<span class="sd">        The `id` property returns the version number/identifier extracted from the name.</span>
<span class="sd">        The `level` property returns the level of the node in the DAG.</span>
<span class="sd">        The `is_root` property returns True if the node has no parents, and the `is_leaf` property returns True if the node has no children.</span>

<span class="sd">        The `AbstractNode` class also provides internal methods to add parents and children to the node.</span>
<span class="sd">        The `_add_child` method adds a child node to the node&#39;s list of children.</span>
<span class="sd">        The `_add_parent` method adds a parent node to the node&#39;s list of parents and updates the level of the node based on the parent&#39;s level.</span>

<span class="sd">        The `AbstractNode` class overrides the `__str__` method to provide a string representation of the node. The representation includes the name, the type of the data, and the data itself.</span>
<span class="sd">        The `AbstractNode` class implements the `__deepcopy__` method to create a deep copy of the node. This allows the node to be detached from the original graph.</span>
<span class="sd">        The `AbstractNode` class provides comparison methods `lt` and `gt` to compare the levels of two nodes in the DAG.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an instance of the AbstractNode class.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: The value to be assigned to the node.</span>
<span class="sd">            name (str, optional): The name of the node. Defaults to None.</span>
<span class="sd">            trainable (bool, optional): Whether the node is trainable or not. Defaults to False.</span>

<span class="sd">        Notes:</span>
<span class="sd">            During initialization, this function generates a default name for the node based on the type of the `value` parameter.</span>
<span class="sd">            If the `name` parameter is provided, it is appended to the default name. The format of the name is &quot;type:version&quot;, where the version is set to 0 if no name is provided.</span>
<span class="sd">            If the `value` parameter is an instance of the Node class, the `_data` attribute of the current node is set to the `_data` attribute of the `value` parameter,</span>
<span class="sd">            and the `_name` attribute is set to the `_name` attribute of the `value` parameter if no name is provided.</span>
<span class="sd">            Otherwise, the `_data` attribute is set to the `value` parameter itself, and the `_name` attribute is set to the default name.</span>
<span class="sd">            Finally, the function calls the `register` function of the GRAPH object to register the current node in the graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_level</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># roots are at level 0</span>
        <span class="n">default_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;:0&quot;</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;:0&quot;</span>  <span class="c1"># name:version</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>  <span class="c1"># just a reference</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">default_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">default_name</span>
        <span class="n">GRAPH</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># When created, register the node to the graph.</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the internal data of a node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Any: The internal data stored in the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If within a trace_nodes context and GRAPH.TRACE is True, adds the node to USED_NODES.</span>
<span class="sd">            This function assumes that the &quot;_data&quot; attribute exists within the node object.</span>
<span class="sd">            If this attribute is not present, an AttributeError will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">USED_NODES</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">GRAPH</span><span class="o">.</span><span class="n">TRACE</span><span class="p">:</span>  <span class="c1"># We&#39;re within trace_nodes context.</span>
            <span class="n">USED_NODES</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="s2">&quot;_data&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the parents of a node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: The list of parent nodes.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This property is an essential part of the graph structure and is used in various operations</span>
<span class="sd">            such as graph traversal and feedback propagation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the children of a node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: The list of child nodes.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This property is essential for accessing the hierarchical structure of nodes,</span>
<span class="sd">            allowing traversal and manipulation of the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the name of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The name of the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This property is set when the node is registered in the graph.</span>
<span class="sd">            It is a combination of the node&#39;s name and its index in the list of nodes with the same name.</span>
<span class="sd">            The index is incremented each time a new node with the same name is registered.</span>
<span class="sd">            This assumes that elements in the `_nodes` dictionary of the graph never get removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">py_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the Python-friendly name of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The name of the node with &quot;:&quot; characters removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the identifier part of the node&#39;s name.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The identifier portion of the node&#39;s name (part after the colon).</span>

<span class="sd">        Notes:</span>
<span class="sd">            The `name` property is a string formatted as &quot;name:identifier&quot;.</span>
<span class="sd">            This property splits that string using the colon (&quot;:&quot;) delimiter and returns the second part,</span>
<span class="sd">            which corresponds to the identifier.</span>
<span class="sd">            Ensure that the `name` attribute contains a colon (&quot;:&quot;) to avoid index errors during the split operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the level of the node in the graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The level of the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The level is determined by the maximum level of its parents plus one.</span>
<span class="sd">            The level of a root node is 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is a root node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the node has no parents, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is a leaf node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the node has no children, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a child node to the current node.</span>

<span class="sd">        Args:</span>
<span class="sd">            child: The child node to be added.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The function first checks if the child node is not the same as the current node itself.</span>
<span class="sd">            If it is, it raises an assertion error (no self-loops allowed in the DAG).</span>
<span class="sd">            It then checks if the child node is an instance of the `Node` class.</span>
<span class="sd">            If it is not, it raises a different assertion error.</span>
<span class="sd">            Finally, it calls the `_add_parent` function of the child node, passing the current node as the parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Cannot add self as a child.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Node</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">child</span><span class="si">}</span><span class="s2"> is not a Node.&quot;</span>
        <span class="n">child</span><span class="o">.</span><span class="n">_add_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a parent node to the current node.</span>

<span class="sd">        Args:</span>
<span class="sd">            parent: The parent node to be added.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The function asserts that the parent node is not the same as the current node itself.</span>
<span class="sd">            This check prevents self-loops in the DAG.</span>
<span class="sd">            It then asserts that the parent node is an instance of the `Node` class.</span>
<span class="sd">            This check ensures that only valid nodes can be added as parents.</span>
<span class="sd">            If both checks pass, the function proceeds to add the current node as a child to the parent node</span>
<span class="sd">            by appending it to the parent&#39;s `_children` attribute. Similarly, it adds the parent node to</span>
<span class="sd">            the current node&#39;s `_parents` attribute.</span>
<span class="sd">            Finally, the function calls the _update_level method to update the level attribute of the current node.</span>
<span class="sd">            It passes the maximum value between the current node&#39;s _level attribute and the parent node&#39;s _level</span>
<span class="sd">            attribute plus one as the new level value.</span>
<span class="sd">            This ensures that the hierarchical structure of the nodes is maintained correctly,</span>
<span class="sd">            with child nodes always having a level greater than or equal to their parent nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Cannot add self as a parent.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Node</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="si">}</span><span class="s2">, which is not a Node.&quot;</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_level</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_level</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># Update the level, because the parent is added</span>

    <span class="k">def</span> <span class="nf">_update_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_level</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the level attribute of the current node.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_level (int): The new level to which the node&#39;s level attribute should be updated.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The function does not perform any validation or checks on the new_level parameter;</span>
<span class="sd">            it directly assigns it to the _level attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GRAPH._levels[self._level].remove(self)  # this uses the == operator which compares values. We need to compare references.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_level</span> <span class="o">=</span> <span class="n">new_level</span>
        <span class="c1"># GRAPH._levels[new_level].append(self)</span>
        <span class="c1"># assert all([len(GRAPH._levels[i]) &gt; 0 for i in range(len(GRAPH._levels))]), &quot;Some levels are empty.&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get string representation of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A string containing the node&#39;s name, data type, and data value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The `__str__` method constructs a string representation of the node by concatenating</span>
<span class="sd">            the node&#39;s name, the data type of the node&#39;s data, and the actual data stored in the node.</span>
<span class="sd">            Doing str(node) allows us to look up the node in the feedback dictionary maintained by</span>
<span class="sd">            Trace during the backward pass easily.</span>
<span class="sd">            Ensure that the node has been properly initialized and registered before calling this</span>
<span class="sd">            method to avoid any unexpected behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># str(node) allows us to look up in the feedback dictionary easily</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Node: (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2">, data=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a deep copy of the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            memo (dict): A dictionary used to keep track of objects that have already been copied.</span>

<span class="sd">        Returns:</span>
<span class="sd">            AbstractNode: A new instance that is a deep copy of the current node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The new instance will be a completely independent copy of the original,</span>
<span class="sd">            with no shared references to mutable objects.</span>
<span class="sd">            1. The function starts by obtaining the class of the current instance (`cls = self.__class__`).</span>
<span class="sd">            2. It then creates a new, uninitialized instance of this class (`result = cls.__new__(cls)`).</span>
<span class="sd">            3. The `memo` dictionary is updated to associate the original instance&#39;s ID with the new instance.</span>
<span class="sd">            This helps in tracking already copied objects to prevent infinite loops.</span>
<span class="sd">            4. The function iterates over all the attributes of the original instance.</span>
<span class="sd">            5. For attributes named `_parents` or `_children`, it sets these attributes in the new instance</span>
<span class="sd">            to empty lists. This ensures that the new instance starts with no parent or child nodes.</span>
<span class="sd">            6. For all other attributes, it performs a deep copy of the attribute&#39;s value and assigns it</span>
<span class="sd">            to the new instance.</span>
<span class="sd">            7. Finally, the new instance is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_parents&quot;</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_children&quot;</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;_feedback&#39;</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="AbstractNode.lt">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.AbstractNode.lt">[docs]</a>
    <span class="k">def</span> <span class="nf">lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare if this node&#39;s level is less than another node&#39;s level.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The other node to compare against.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if this node&#39;s level is less than the other node&#39;s level.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This method is used to compare the levels of two nodes in the DAG.</span>
<span class="sd">            Therefore it checks if the negated level of the current node (`-self._level`)</span>
<span class="sd">            is less than the negated level of the other node (`-other._level`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_level</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">_level</span></div>


<div class="viewcode-block" id="AbstractNode.gt">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.AbstractNode.gt">[docs]</a>
    <span class="k">def</span> <span class="nf">gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare if this node&#39;s level is greater than another node&#39;s level.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The other node to compare against.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if this node&#39;s level is greater than the other node&#39;s level.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This method is used to compare the levels of two nodes in the DAG.</span>
<span class="sd">            Therefore it checks if the negated level of the current node (`-self._level`)</span>
<span class="sd">            is greater than the negated level of the other node (`-other._level`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_level</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">_level</span></div>
</div>



<span class="c1"># These are operators that do not change the data type and can be viewed as identity operators.</span>
<span class="n">IDENTITY_OPERATORS</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;identity&quot;</span><span class="p">,</span> <span class="s2">&quot;clone&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="get_op_name">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.get_op_name">[docs]</a>
<span class="k">def</span> <span class="nf">get_op_name</span><span class="p">(</span><span class="n">description</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract the operator type from the description.</span>

<span class="sd">    Args:</span>
<span class="sd">        description (str): A string containing the description of the node.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: The extracted operator type.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the description does not contain an operator type in square brackets.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The `get_op_name` function takes a description as input and uses regular expression</span>
<span class="sd">        to search for the operator type enclosed in square brackets at the beginning of the description.</span>
<span class="sd">        If a match is found, the operator type is extracted and returned.</span>
<span class="sd">        Otherwise, a `ValueError` is raised with a specific error message.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">description</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Description must be a string, but it is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">description</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\[([^\[\]]+)\]&quot;</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
        <span class="n">operator_type</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">operator_type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The description &#39;</span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s2">&#39; must contain the operator type in square brackets.&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="NodeVizStyleGuide">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuide">[docs]</a>
<span class="k">class</span> <span class="nc">NodeVizStyleGuide</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to provide a standardized way to visualize nodes in a graph.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        style (str): Defines the style of the visualization. Default is &#39;default&#39;.</span>
<span class="sd">        print_limit (int): Sets the maximum number of characters to print for node descriptions and content. Default is 100.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">print_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the NodeVizStyleGuide.</span>

<span class="sd">        Args:</span>
<span class="sd">            style (str, optional): The style of visualization to use. Defaults to &#39;default&#39;.</span>
<span class="sd">            print_limit (int, optional): Maximum characters to print for descriptions and content. Defaults to 100.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">style</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_limit</span> <span class="o">=</span> <span class="n">print_limit</span>

<div class="viewcode-block" id="NodeVizStyleGuide.get_attrs">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuide.get_attrs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the attributes for a node based on the style guide.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which attributes are to be generated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary of visualization attributes for the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The attributes include the label, shape, fill color, and style of the node,</span>
<span class="sd">            which are determined based on the node&#39;s properties and the style guide.</span>
<span class="sd">            The method calls other helper methods to construct the label, determine the node shape,</span>
<span class="sd">            assign a color, and set the style.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_shape</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;fillcolor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_color</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">attrs</span></div>


<div class="viewcode-block" id="NodeVizStyleGuide.get_label">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuide.get_label">[docs]</a>
    <span class="k">def</span> <span class="nf">get_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a label for a node.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which the label is to be constructed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The constructed label string.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Using a colon in the name can cause problems in graph visualization tools like Graphviz.</span>
<span class="sd">            To avoid issues, the label is constructed by combining the node&#39;s Python name,</span>
<span class="sd">            truncated description, and content.</span>
<span class="sd">            If the description or content exceeds the print limit, it is truncated and appended with an ellipsis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># using colon in the name causes problems in graphviz</span>
        <span class="n">description</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">description</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">description</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_limit</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">description</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">print_limit</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>

        <span class="n">text</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">py_name</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">description</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">content</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;content&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="n">content</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;content&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_limit</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">content</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">print_limit</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>
        <span class="k">return</span> <span class="n">text</span> <span class="o">+</span> <span class="n">content</span></div>


<div class="viewcode-block" id="NodeVizStyleGuide.get_node_shape">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuide.get_node_shape">[docs]</a>
    <span class="k">def</span> <span class="nf">get_node_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the shape of a node.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which the shape is to be determined.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The shape to use for the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The shape of a node is determined based on its type.</span>
<span class="sd">            ParameterNode types are represented as &#39;box&#39;,</span>
<span class="sd">            while other types are represented as &#39;ellipse&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">ParameterNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;box&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;ellipse&quot;</span></div>


<div class="viewcode-block" id="NodeVizStyleGuide.get_color">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuide.get_color">[docs]</a>
    <span class="k">def</span> <span class="nf">get_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign a color to a node.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which the color is to be assigned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The color to use for the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The color of a node is determined based on its type.</span>
<span class="sd">            ExceptionNode types are colored &#39;firebrick1&#39;,</span>
<span class="sd">            and ParameterNode types are colored &#39;lightgray&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">ExceptionNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;firebrick1&#39;</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">ParameterNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#DEEBF6&#39;</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>


<div class="viewcode-block" id="NodeVizStyleGuide.get_style">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuide.get_style">[docs]</a>
    <span class="k">def</span> <span class="nf">get_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the style of a node.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which the style is to be set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The style string for the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The style of a node is set to &#39;filled,solid&#39; if the node is trainable;</span>
<span class="sd">            otherwise, it returns an empty string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;filled,solid&#39;</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">trainable</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span></div>
</div>



<div class="viewcode-block" id="NodeVizStyleGuideColorful">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuideColorful">[docs]</a>
<span class="k">class</span> <span class="nc">NodeVizStyleGuideColorful</span><span class="p">(</span><span class="n">NodeVizStyleGuide</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to provide a colorful style guide for visualizing nodes in a graph.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        style (str): Defines the style of the visualization. Default is &#39;default&#39;.</span>
<span class="sd">        print_limit (int): Sets the maximum number of characters to print for node descriptions and content. Default is 100.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">print_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the NodeVizStyleGuideColorful.</span>

<span class="sd">        Args:</span>
<span class="sd">            style (str, optional): The style of visualization to use. Defaults to &#39;default&#39;.</span>
<span class="sd">            print_limit (int, optional): Maximum characters to print for descriptions and content. Defaults to 100.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">style</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_limit</span> <span class="o">=</span> <span class="n">print_limit</span>

<div class="viewcode-block" id="NodeVizStyleGuideColorful.get_attrs">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuideColorful.get_attrs">[docs]</a>
    <span class="k">def</span> <span class="nf">get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the attributes for a node based on the colorful style guide.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which attributes are to be generated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary of visualization attributes for the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The attributes include the label, shape, fill color, style, border color,</span>
<span class="sd">            and border width of the node, which are determined based on the node&#39;s properties</span>
<span class="sd">            and the style guide. The method calls other helper methods to construct the label,</span>
<span class="sd">            determine the node shape, assign a color, and set the style.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_shape</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;fillcolor&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_color</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;style&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_style</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_border_color</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="s1">&#39;penwidth&#39;</span><span class="p">:</span> <span class="s2">&quot;1.2&quot;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">attrs</span></div>


<div class="viewcode-block" id="NodeVizStyleGuideColorful.get_border_color">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuideColorful.get_border_color">[docs]</a>
    <span class="k">def</span> <span class="nf">get_border_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign a border color to a node.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which the border color is to be assigned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The border color to use for the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The border color of a node is determined based on its type.</span>
<span class="sd">            ExceptionNode types are colored &#39;firebrick1&#39;,</span>
<span class="sd">            and ParameterNode types are colored &#39;black&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">ExceptionNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;black&#39;</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">ParameterNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#FF7E79&#39;</span>

        <span class="k">return</span> <span class="s2">&quot;#5C9BD5&quot;</span></div>


<div class="viewcode-block" id="NodeVizStyleGuideColorful.get_color">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuideColorful.get_color">[docs]</a>
    <span class="k">def</span> <span class="nf">get_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign a fill color to a node.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which the fill color is to be assigned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The fill color to use for the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The fill color of a node is determined based on its type.</span>
<span class="sd">            ExceptionNode types are colored &#39;firebrick1&#39;,</span>
<span class="sd">            and ParameterNode types are colored &#39;lightgray&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">ExceptionNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;firebrick1&#39;</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">ParameterNode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;#FFE5E5&#39;</span>

        <span class="k">return</span> <span class="s2">&quot;#DEEBF6&quot;</span></div>


<div class="viewcode-block" id="NodeVizStyleGuideColorful.get_style">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.NodeVizStyleGuideColorful.get_style">[docs]</a>
    <span class="k">def</span> <span class="nf">get_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the style of a node always as if it is trainable.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The node for which the style is to be set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The style string &#39;filled,solid&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;filled,solid&#39;</span></div>
</div>



<div class="viewcode-block" id="Node">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node">[docs]</a>
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">AbstractNode</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A data node in a directed graph, this is a basic data structure of Trace.</span>

<span class="sd">    Args:</span>
<span class="sd">        value (Any): The value to be assigned to the node.</span>
<span class="sd">        name (str, optional): The name of the node.</span>
<span class="sd">        trainable (bool, optional): Whether the node is trainable or not. Defaults to False.</span>
<span class="sd">        description (str, optional): String describing the node. Defaults to &quot;[Node] This is a node in a computational graph.&quot;</span>
<span class="sd">        constraint (Union[None, str], optional): String describing constraints that the data should satisfy. Defaults to None.</span>
<span class="sd">        info (Union[None, Dict], optional): Dictionary containing additional information about the node. Defaults to None.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        trainable (bool): Whether the node is trainable or not.</span>
<span class="sd">        _feedback (dict): Dictionary of feedback from children nodes.</span>
<span class="sd">        _description (str): String describing the node.</span>
<span class="sd">        _constraint (str): String describing all constraints that the data should satisfy.</span>
<span class="sd">        _backwarded (bool): Whether the backward method has been called.</span>
<span class="sd">        _info (dict): Dictionary containing additional information about the node.</span>
<span class="sd">        _dependencies (dict): Dictionary of dependencies on parameters and expandable nodes.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The Node class extends AbstractNode to represent a data node in a directed graph.</span>
<span class="sd">        It includes attributes and methods to handle feedback, constraints, and dependencies.</span>
<span class="sd">        The node can be marked as trainable and store feedback from children nodes.</span>
<span class="sd">        The feedback mechanism is analogous to gradients in machine learning and propagates</span>
<span class="sd">        information back through the graph. The feedback mechanism supports non-commutative</span>
<span class="sd">        aggregation, so feedback should be handled carefully to maintain correct operation order.</span>
<span class="sd">        The node can track dependencies on parameters and expandable nodes (nodes that depend</span>
<span class="sd">        on parameters not visible in the current graph level).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">trainable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;[Node] This is a node in a computational graph.&quot;</span><span class="p">,</span>
            <span class="n">constraint</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">info</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an instance of the Node class.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: The value to be assigned to the node.</span>
<span class="sd">            name: The name of the node (optional).</span>
<span class="sd">            trainable: A boolean indicating whether the node is trainable or not (optional).</span>
<span class="sd">            description: A string describing the node (optional).</span>
<span class="sd">            constraint: A string describing constraints on the node (optional).</span>
<span class="sd">            info: A dictionary containing additional information about the node (optional).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">description</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;[Node] This is a node in a computational graph.&quot;</span>

        <span class="n">matched</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\[([^\[\]]+)\]&quot;</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;[Node] &#39;</span> <span class="o">+</span> <span class="n">description</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trainable</span> <span class="o">=</span> <span class="n">trainable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feedback</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span>
            <span class="nb">list</span>
        <span class="p">)</span>  <span class="c1"># (analogous to gradient) this is the feedback from the user. Each key is a child and the value is a list of feedbacks from the child.</span>
        <span class="c1"># We keep the propagated feedback as dict and let the propagator performs</span>
        <span class="c1"># the aggreation, rather than doing the aggregation incrementally. This is</span>
        <span class="c1"># to support implementing aggregation that is not commutable.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_description</span> <span class="o">=</span> <span class="n">description</span>  <span class="c1"># Information to describe of the node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraint</span> <span class="o">=</span> <span class="n">constraint</span>  <span class="c1"># A constraint on the node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backwarded</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># True if backward has been called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_info</span> <span class="o">=</span> <span class="n">info</span>  <span class="c1"># Additional information about the node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;parameter&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(),</span>
                              <span class="s1">&#39;expandable&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">()}</span>  <span class="c1"># A dictionary of dependencies on parameters and expandable nodes; expandable nodes are those who depened on parameters not visible in the current graph level.</span>

<div class="viewcode-block" id="Node.zero_feedback">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.zero_feedback">[docs]</a>
    <span class="k">def</span> <span class="nf">zero_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># set feedback to zero</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Zero out the feedback of the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            zero_feedback should be used judiciously within the feedback propagation process to avoid unintended loss of feedback data.</span>
<span class="sd">            It is specifically designed to be used after feedback has been successfully propagated to parent nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feedback</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The feedback from children nodes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feedback</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A textual description of the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_description</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Additional information about the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The type of the data stored in the node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameter_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The depended parameters.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Ensure that the &#39;_dependencies&#39; attribute is properly initialized and contains a &#39;parameter&#39; key</span>
<span class="sd">            with a corresponding value before calling the parameter_dependencies function to avoid potential</span>
<span class="sd">            KeyError exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expandable_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The depended expandable nodes.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Expandable nodes are those who depend on parameters not visible in the current graph level.</span>
<span class="sd">            Ensure that the &#39;_dependencies&#39; attribute is properly initialized and contains an &#39;expandable&#39; key</span>
<span class="sd">            with a corresponding value before calling the expandable_dependencies function to avoid potential</span>
<span class="sd">            KeyError exceptions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;expandable&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_add_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">feedback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add feedback from a child.</span>

<span class="sd">        Args:</span>
<span class="sd">            child: The child node from which feedback is received.</span>
<span class="sd">            feedback: The feedback received from the child node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_feedback</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feedback</span><span class="p">)</span>

    <span class="c1"># This is not traced</span>
    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the value of the node. If value is Node, it will be unwrapped.</span>

<span class="sd">        Args:</span>
<span class="sd">            value: The value to be assigned to the node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The `_set` method sets the `_data` attribute of the node to the provided `value`.</span>
<span class="sd">            If the `value` is an instance of the `Node` class, the `_data` attribute of the current node</span>
<span class="sd">            is set to the `_data` attribute of the `value` parameter.</span>
<span class="sd">            Otherwise, the `_data` attribute is set to the `value` parameter itself.</span>
<span class="sd">            When `_data` is set using `_set`, that usage is not traced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_itemize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># for priority queue</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a tuple containing the node&#39;s level.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple containing (-level, id, self) used for priority queue ordering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">level</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Node.backward">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.backward">[docs]</a>
    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">feedback</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">propagator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">retain_graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">visualize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">simple_visualization</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">reverse_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">print_limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a backward pass in a computational graph.</span>

<span class="sd">        This function propagates feedback from the current node to its parents, updates the graph</span>
<span class="sd">        visualization if required, and returns the resulting graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            feedback: The feedback given to the current node.</span>
<span class="sd">            propagator: A function that takes in a node and a feedback, and returns a dict of {parent: parent_feedback}.</span>
<span class="sd">                       If not provided, a default `GraphPropagator` object is used.</span>
<span class="sd">            retain_graph: If True, the graph will be retained after backward pass.</span>
<span class="sd">            visualize: If True, the graph will be visualized using graphviz.</span>
<span class="sd">            simple_visualization: If True, identity operators will be skipped in the visualization.</span>
<span class="sd">            reverse_plot: if True, plot the graph in reverse order (from child to parent).</span>
<span class="sd">            print_limit: The maximum number of characters to print for node descriptions and content.</span>

<span class="sd">        Returns:</span>
<span class="sd">            digraph: The visualization graph object if visualize=True, None otherwise.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AttributeError: If the node has already been backwarded.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The function checks if the current node has already been backwarded. If it has, an AttributeError is raised.</span>
<span class="sd">            For root nodes (no parents), only visualization is performed if enabled.</span>
<span class="sd">            For non-root nodes, feedback is propagated through the graph using a priority queue to ensure correct ordering.</span>
<span class="sd">            The propagator computes feedback for parent nodes based on the current node&#39;s description, data and feedback.</span>
<span class="sd">            Visualization is handled using graphviz if enabled, with options to simplify the graph by skipping identity operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">propagator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">opto.trace.propagators.graph_propagator</span> <span class="kn">import</span> <span class="n">GraphPropagator</span>  <span class="c1"># this avoids circular import</span>

            <span class="n">propagator</span> <span class="o">=</span> <span class="n">GraphPropagator</span><span class="p">()</span>

        <span class="c1"># Setup for visualization</span>
        <span class="n">digraph</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nvsg</span> <span class="o">=</span> <span class="n">NodeVizStyleGuideColorful</span><span class="p">(</span><span class="n">print_limit</span><span class="o">=</span><span class="n">print_limit</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">graphviz</span> <span class="kn">import</span> <span class="n">Digraph</span>

            <span class="n">digraph</span> <span class="o">=</span> <span class="n">Digraph</span><span class="p">()</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Check for root node with no parents</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backwarded</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> has been backwarded.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_feedback</span><span class="p">(</span><span class="n">Node</span><span class="p">(</span><span class="s2">&quot;FEEDBACK_ORACLE&quot;</span><span class="p">),</span> <span class="n">propagator</span><span class="o">.</span><span class="n">init_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feedback</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># This is a root. Nothing to propagate</span>
            <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
                <span class="n">digraph</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">py_name</span><span class="p">,</span> <span class="o">**</span><span class="n">nvsg</span><span class="o">.</span><span class="n">get_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="c1"># self._backwarded = not retain_graph  # only need to be set for MessageNode</span>
            <span class="k">return</span> <span class="n">digraph</span>

        <span class="c1"># TODO check memory leak</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_itemize</span><span class="p">()]</span>  <span class="c1"># priority queue; add id() since __eq__ is overloaded to compare values.</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>  <span class="c1"># All the children of this node have been visited</span>
                <span class="c1"># Each node is a MessageNode, which has at least one parent.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">MessageNode</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">_backwarded</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> has been backwarded.&quot;</span><span class="p">)</span>

                <span class="c1"># Propagate information from node to its parents</span>
                <span class="n">propagated_feedback</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># Zero-out the feedback once it&#39;s propagated.</span>
                <span class="c1"># This is to ensure the feedback is not double counted when retain_graph is True.</span>
                <span class="n">node</span><span class="o">.</span><span class="n">zero_feedback</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">propagated_feedback</span><span class="p">:</span>
                        <span class="n">parent</span><span class="o">.</span><span class="n">_add_feedback</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">propagated_feedback</span><span class="p">[</span><span class="n">parent</span><span class="p">])</span>

                    <span class="c1"># Put parent in the queue if it has not been visited and it&#39;s not a root</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">parent</span><span class="o">.</span><span class="n">_itemize</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">:</span>  <span class="c1"># and parent not in queue:</span>
                        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">_itemize</span><span class="p">())</span>  <span class="c1"># put parent in the priority queue</span>

                    <span class="k">if</span> <span class="n">visualize</span><span class="p">:</span>
                        <span class="c1"># Plot the edge from parent to node</span>
                        <span class="c1"># Bypass chain of identity operators (for better visualization)</span>
                        <span class="k">while</span> <span class="p">(</span><span class="n">get_op_name</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">description</span><span class="p">)</span> <span class="ow">in</span> <span class="n">IDENTITY_OPERATORS</span><span class="p">)</span> <span class="ow">and</span> <span class="n">simple_visualization</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># identity operators should have only one parent</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">py_name</span><span class="p">)</span>  <span class="c1"># skip this node in visualization</span>
                            <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                        <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">py_name</span><span class="p">,</span> <span class="n">parent</span><span class="o">.</span><span class="n">py_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">reverse_plot</span> <span class="k">else</span> <span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">py_name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">py_name</span><span class="p">)</span>
                        <span class="c1"># Just plot the edge once, since the same node can be</span>
                        <span class="c1"># visited multiple times (e.g., when that node has</span>
                        <span class="c1"># multiple children).</span>
                        <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">py_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">digraph</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                            <span class="n">digraph</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">py_name</span><span class="p">,</span> <span class="o">**</span><span class="n">nvsg</span><span class="o">.</span><span class="n">get_attrs</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
                            <span class="n">digraph</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">py_name</span><span class="p">,</span> <span class="o">**</span><span class="n">nvsg</span><span class="o">.</span><span class="n">get_attrs</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>

                <span class="n">node</span><span class="o">.</span><span class="n">_backwarded</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">retain_graph</span>  <span class="c1"># set backwarded to True</span>

            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># queue is empty</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">digraph</span></div>


<div class="viewcode-block" id="Node.clone">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and return a duplicate of the current Node object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A clone of the current node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.detach">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.detach">[docs]</a>
    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and return a deep copy of the current instance of the Node class.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A deep copy of the current node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="c1"># Get attribute and call operators</span>
<div class="viewcode-block" id="Node.getattr">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.getattr">[docs]</a>
    <span class="k">def</span> <span class="nf">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the attribute of the node with the specified key.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The key of the attribute to get.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the requested attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">node_getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>


<div class="viewcode-block" id="Node.call">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.call">[docs]</a>
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call the function with the specified arguments and keyword arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            fun: The function to call.</span>
<span class="sd">            *args: The arguments to pass to the function.</span>
<span class="sd">            **kwargs: The keyword arguments to pass to the function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: The result of the function call wrapped in a node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>  <span class="c1"># convert args to nodes</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getattr</span><span class="p">(</span><span class="n">fun</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call the function with the specified arguments and keyword arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            *args: The arguments to pass to the function.</span>
<span class="sd">            **kwargs: The keyword arguments to pass to the function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: The result of the function call wrapped in a node.</span>

<span class="sd">        Notes:</span>
<span class="sd">            By using the __call__ method, the Node object can be used as if it were a regular</span>
<span class="sd">            callable function, providing a seamless interface for function invocation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="c1"># We overload magic methods that return a value. These methods return a MessageNode.</span>
    <span class="c1"># container magic methods</span>
<div class="viewcode-block" id="Node.len">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.len">[docs]</a>
    <span class="k">def</span> <span class="nf">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the length of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the length value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">len_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the item at the specified key.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The key of the item to get.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the requested item.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the item is contained in the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            item: The item to check for containment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the boolean result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">in_</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">item</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># Unary operators and functions</span>
    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the positive value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the positive value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the negative value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the negative value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the absolute value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the absolute value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the inverted value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the inverted value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the rounded value of the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: The number of decimal places to round to (optional).</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the rounded value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__floor__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the floor value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the floor value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ceil__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the ceiling value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the ceiling value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__trunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the truncated value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the truncated value.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1">## Normal arithmetic operators</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sum of the node and another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to add to the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the sum.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sum of another value and the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to add to the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the sum.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the difference between the node and another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to subtract from the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the difference.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the difference between another value and the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to subtract the node from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the difference.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the product of the node and another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to multiply the node by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the product.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the product of another value and the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to multiply the node by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the product.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the floor division of the node by another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide the node by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the floor division result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the floor division of another value by the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide by the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the floor division result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the true division of the node by another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide the node by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the division result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the true division of another value by the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide by the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the division result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the division of the node by another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide the node by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the division result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the division of another value by the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide by the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the division result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the modulo of the node by another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide the node by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the modulo result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the modulo of another value by the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide by the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the modulo result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the division and modulo of the node by another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide the node by.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the division and modulo results.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">node_divmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the division and modulo of another value by the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to divide by the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the division and modulo results.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the power of the node raised to another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The exponent value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the power result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the power of another value raised to the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The base value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the power result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the left shift of the node by another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The number of positions to shift.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the left shift result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">lshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the left shift of another value by the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to shift.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the left shift result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the right shift of the node by another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The number of positions to shift.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the right shift result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">rshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the right shift of another value by the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to shift.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the right shift result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bitwise AND of the node and another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to AND with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the AND result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">and_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bitwise AND of another value and the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to AND with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the AND result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">&amp;</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bitwise OR of the node and another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to OR with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the OR result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">or_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bitwise OR of another value and the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to OR with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the OR result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">|</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bitwise XOR of the node and another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to XOR with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the XOR result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the bitwise XOR of another value and the node.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to XOR with.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the XOR result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            We overload magic methods that return a value. This method returns a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">^</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an iterator for the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            iterator: An iterator over the node&#39;s data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The Node object must have a data attribute that is a list, tuple, set, or dictionary.</span>
<span class="sd">            The iterate function called by __iter__ handles the conversion of sets to lists and wraps items in lists or dictionaries with node objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.iterators</span> <span class="k">as</span> <span class="nn">it</span>

        <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the length of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The length of the node&#39;s data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            __len__ restricts return type to be integer.</span>
<span class="sd">            Therefore, this method only returns integer.</span>
<span class="sd">            If a Node/MessageNode is desired to be returned, call node.len() instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="c1"># for logic operators</span>
    <span class="c1"># case 1: used in if-statement, then we should return a bool</span>
    <span class="c1"># case 2: used else-where, then we should return Node(bool)</span>
    <span class="c1"># we can&#39;t quite distinguish myopically, so...in here, we prioritize case 1</span>
    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is less than another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to compare the node to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the comparison result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If a logic operator is used in an if-statement, it will return a boolean value.</span>
<span class="sd">            Otherwise, it will return a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="c1"># if isinstance(other, Node):</span>
        <span class="c1">#     other = other.data</span>
        <span class="c1"># return self._data &lt; other</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is less than or equal to another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to compare the node to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the comparison result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If a logic operator is used in an if-statement, it will return a boolean value.</span>
<span class="sd">            Otherwise, it will return a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="c1"># if isinstance(other, Node):</span>
        <span class="c1">#     other = other.data</span>
        <span class="c1"># return self._data &lt;= other</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is greater than another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to compare the node to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the comparison result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If a logic operator is used in an if-statement, it will return a boolean value.</span>
<span class="sd">            Otherwise, it will return a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="c1"># if isinstance(other, Node):</span>
        <span class="c1">#     other = other.data</span>
        <span class="c1"># return self._data &gt; other</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is greater than or equal to another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to compare the node to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the comparison result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If a logic operator is used in an if-statement, it will return a boolean value.</span>
<span class="sd">            Otherwise, it will return a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="c1"># if isinstance(other, Node):</span>
        <span class="c1">#     other = other.data</span>
        <span class="c1"># return self._data &gt;= other</span>

    <span class="c1"># this creates a lot of issues if we return Node</span>
    <span class="c1"># instead of bool (for example &quot;in&quot; operator will not work)</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is equal to another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to compare the node to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the values are equal, False otherwise.</span>

<span class="sd">        Notes:</span>
<span class="sd">            __eq__ restricts return type to be bool; otherwise, it will create issues (for example, the &quot;in&quot; operator will not work).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># import opto.trace.operators as ops</span>
        <span class="c1"># return ops.eq(self, node(other))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="Node.eq">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.eq">[docs]</a>
    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is equal to another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to compare the node to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the comparison result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If a logic operator is used in an if-statement, it will return a boolean value.</span>
<span class="sd">            Otherwise, it will return a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>
        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>


<div class="viewcode-block" id="Node.neq">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.neq">[docs]</a>
    <span class="k">def</span> <span class="nf">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the node is not equal to another value.</span>

<span class="sd">        Args:</span>
<span class="sd">            other: The value to compare the node to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Node: A node containing the comparison result.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If a logic operator is used in an if-statement, it will return a boolean value.</span>
<span class="sd">            Otherwise, it will return a MessageNode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>
        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">neq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the hash value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The hash value of the node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the boolean value of the node.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: The boolean value of the node&#39;s data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The access to the `_data` attribute happening in this method is not traced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># not tracing this conversion</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="c1"># string operators</span>
<div class="viewcode-block" id="Node.format">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.format">[docs]</a>
    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;format&#39;.&quot;</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.capitalize">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.capitalize">[docs]</a>
    <span class="k">def</span> <span class="nf">capitalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;capitalize&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.lower">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.lower">[docs]</a>
    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;lower&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.upper">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.upper">[docs]</a>
    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;upper&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.swapcase">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.swapcase">[docs]</a>
    <span class="k">def</span> <span class="nf">swapcase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;swapcase&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">swapcase</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.title">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.title">[docs]</a>
    <span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;title&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.split">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.split">[docs]</a>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;split&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">maxsplit</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.strip">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.strip">[docs]</a>
    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;strip&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.replace">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.replace">[docs]</a>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;replace&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">old</span><span class="p">),</span> <span class="n">node</span><span class="p">(</span><span class="n">new</span><span class="p">),</span> <span class="n">count</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.join">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.join">[docs]</a>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;join&#39;.&quot;</span><span class="p">)</span>
        <span class="c1"># test if seq is a sequence</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can only join an iterable.&quot;</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">seq</span><span class="p">)</span></div>


    <span class="c1"># container specific methods</span>
<div class="viewcode-block" id="Node.items">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.items">[docs]</a>
    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;items&#39;.&quot;</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">opto.trace.iterators</span> <span class="k">as</span> <span class="nn">it</span>

        <span class="k">return</span> <span class="n">it</span><span class="o">.</span><span class="n">DictIterable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.values">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.values">[docs]</a>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.keys">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.keys">[docs]</a>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> object has no attribute &#39;keys&#39;.&quot;</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Node.pop">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.pop">[docs]</a>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">__index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># python does hidden type checks</span>
        <span class="kn">import</span> <span class="nn">opto.trace.operators</span> <span class="k">as</span> <span class="nn">ops</span>

        <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">(</span><span class="n">__index</span><span class="p">))</span></div>


<div class="viewcode-block" id="Node.append">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.Node.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;append&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ParameterNode">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.ParameterNode">[docs]</a>
<span class="k">class</span> <span class="nc">ParameterNode</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="c1"># This is a shorthand of a trainable Node.</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">description</span><span class="o">=</span><span class="s2">&quot;[ParameterNode] This is a ParameterNode in a computational graph.&quot;</span><span class="p">,</span>
            <span class="n">constraint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">description</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;[ParameterNode] This is a ParameterNode in a computational graph.&quot;</span>

        <span class="n">matched</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\[([^\[\]]+)\]&quot;</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
            <span class="n">description</span> <span class="o">=</span> <span class="s1">&#39;[ParameterNode] &#39;</span> <span class="o">+</span> <span class="n">description</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="n">trainable</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># str(node) allows us to look up in the feedback dictionary easily</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ParameterNode: (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2">, data=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="si">}</span><span class="s2">)&quot;</span></div>



<div class="viewcode-block" id="MessageNode">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.MessageNode">[docs]</a>
<span class="k">class</span> <span class="nc">MessageNode</span><span class="p">(</span><span class="n">Node</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A node representing the output of an operator.</span>

<span class="sd">    The description string should begin with [operator_name] followed by details about the operator.</span>
<span class="sd">    When referring to inputs in the description, use either:</span>
<span class="sd">    - The keys in args (if args is a dict)</span>
<span class="sd">    - The names of the nodes in args (if args is a list)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; MessageNode(node_a, inputs=[node_a],</span>
<span class="sd">        &gt;&gt;&gt;        description=&quot;[identity] This is an identity operator.&quot;)</span>
<span class="sd">        &gt;&gt;&gt; MessageNode(copy_node_a, inputs=[node_a],</span>
<span class="sd">        &gt;&gt;&gt;        description=&quot;[copy] This is a copy operator.&quot;)</span>
<span class="sd">        &gt;&gt;&gt; MessageNode(1, inputs={&#39;a&#39;:node_a, &#39;b&#39;:node_b},</span>
<span class="sd">        &gt;&gt;&gt;        description=&quot;[Add] This is an add operator of a and b.&quot;)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        value: The output value of the operator</span>
<span class="sd">        inputs (Union[List[Node], Dict[str, Node]]): Input nodes to the operator</span>
<span class="sd">        description (str): Description string starting with [operator_name]</span>
<span class="sd">        constraint: Optional constraints on the output</span>
<span class="sd">        name (str, optional): Name of the node</span>
<span class="sd">        info (optional): Additional operator information</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO document what needs to go into info</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">]],</span>  <span class="c1"># extra</span>
            <span class="n">description</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">constraint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Inputs to MessageNode must be a list or a dict.&quot;</span>
        <span class="c1"># If inputs is not a dict, we create a dict with the names of the nodes as keys</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># If not tracing, MessageNode would just behave like a Node.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">GRAPH</span><span class="o">.</span><span class="n">TRACE</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;MessageNode should have no inputs when not tracing.&quot;</span>

        <span class="c1"># Add parents if we are tracing</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Node</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Input </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> is not a Node.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_parent</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_dependencies</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># Initializes the dependencies on parameter and expandable nodes</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_dependencies</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;expandable&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># str(node) allows us to look up in the feedback dictionary easily</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;MessageNode: (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2">, data=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">_add_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">feedback</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add feedback from a child.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_add_feedback</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">feedback</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_feedback</span><span class="p">[</span><span class="n">child</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;MessageNode should have only one feedback from each child.&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hidden_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># this needs to be recursive</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the set of hidden dependencies that are not visible in the current graph level.&quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;inputs&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;args&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">][</span><span class="s1">&#39;kwargs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">if</span> <span class="s1">&#39;output&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Node</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">):</span>  <span class="c1"># traceable code</span>
            <span class="c1"># The inner function is traceable.</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">|</span> <span class="p">(</span>
                        <span class="n">output</span><span class="o">.</span><span class="n">parameter_dependencies</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_dependencies</span><span class="p">)</span>  <span class="c1"># add extra parameters explicitly used in the inner function</span>
            <span class="n">extra_expandable</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">expandable_dependencies</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expandable_dependencies</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">extra_expandable</span><span class="p">:</span>  <span class="c1"># add extra hidden dependencies</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">|</span> <span class="n">n</span><span class="o">.</span><span class="n">hidden_dependencies</span>
        <span class="k">return</span> <span class="n">diff</span>

    <span class="k">def</span> <span class="nf">_add_dependencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Cannot add self as a parent.&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Node</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span><span class="si">}</span><span class="s2">, which is not a Node.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">parent</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;parameter&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;expandable&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;expandable&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">parent</span><span class="o">.</span><span class="n">_dependencies</span><span class="p">[</span><span class="s1">&#39;expandable&#39;</span><span class="p">]</span></div>



<div class="viewcode-block" id="ExceptionNode">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.ExceptionNode">[docs]</a>
<span class="k">class</span> <span class="nc">ExceptionNode</span><span class="p">(</span><span class="n">MessageNode</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Node containing the exception message.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">value</span><span class="p">:</span> <span class="ne">Exception</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Node</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Node</span><span class="p">]],</span>
            <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;[ExceptionNode] This is node containing the error of execution.&quot;</span><span class="p">,</span>
            <span class="n">constraint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">error_type</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&lt;class &#39;(.*)&#39;&gt;&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">opto</span> <span class="kn">import</span> <span class="n">trace</span>
        <span class="n">value</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">error_type</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span> <span class="n">constraint</span><span class="o">=</span><span class="n">constraint</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>

<div class="viewcode-block" id="ExceptionNode.create_feedback">
<a class="viewcode-back" href="../../../api/opto/opto.trace.nodes.html#opto.trace.ExceptionNode.create_feedback">[docs]</a>
    <span class="k">def</span> <span class="nf">create_feedback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;simple&#39;</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">style</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;simple&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span>
        <span class="n">feedback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="n">style</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;error_comment&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">feedback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;error_comment&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">feedback</span></div>
</div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="s2">&quot;Node X&quot;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="s2">&quot;Node Y&quot;</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">MessageNode</span><span class="p">(</span><span class="s2">&quot;Node Z&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">},</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;[Add] This is an add operator of x and y.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">z</span><span class="o">.</span><span class="n">parents</span><span class="p">])</span>

    <span class="n">x</span><span class="p">:</span> <span class="n">AbstractNode</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="s2">&quot;Node X&quot;</span><span class="p">)</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Node</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="s2">&quot;Node X&quot;</span><span class="p">)</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ParameterNode</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">ParameterNode</span><span class="p">(</span><span class="s2">&quot;Node X&quot;</span><span class="p">,</span> <span class="n">trainable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">MessageNode</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">MessageNode</span><span class="p">(</span>
        <span class="s2">&quot;Node X&quot;</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">},</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;[Add] This is an add operator of x and y.&quot;</span>
    <span class="p">)</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Ching-An Cheng, Allen Nie, Adith Swaminathan
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      ¬© Copyright 2024 Trace Team.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  <a href='mailto:chinganc@microsoft.com'>Contact Us</a> | <a href='http://go.microsoft.com/fwlink/?LinkId=521839'>Privacy &amp; Cookies</a> | <a href='https://go.microsoft.com/fwlink/?linkid=2259814'>Consumer Health Privacy</a> | <a href='https://go.microsoft.com/fwlink/?LinkID=206977'>Terms Of Use</a> | <a href='https://www.microsoft.com/trademarks'>Trademarks</a>
</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>